#!/usr/bin/env node
var fs = require('fs'),
    path = require('path'),
    subarg = require('subarg');

var argv = subarg(process.argv.slice(2));

// defaults

var config = { };

if (argv.init) {
  console.log(fs.readFileSync(__dirname + '/default-config.json').toString());
  process.exit();
  return;
}

if (argv.help) {
  console.log(fs.readFileSync(__dirname + '/usage.txt').toString());
  process.exit();
  return;
}

if (argv.settings) {
  var settingsPath = path.resolve(process.cwd(), argv.settings);
  var loaded = require(settingsPath);

  // resolve relative to the config file location
  ['input', 'output', 'theme'].forEach(function(key) {
    loaded[key] = path.resolve(path.dirname(settingsPath), loaded[key]);
  });

  Object.keys(loaded).forEach(function(key) {
    // loaded file overrides all values that were not set yet
    if (typeof config[key] === 'undefined') {
      config[key] = loaded[key];
    }
  });
} else {
  console.log('The --settings command line argument is required.');
  process.exit();
  return;
}

if (!config.input) {
  config.input = path.resolve(process.cwd(), argv.input || './input/');
}
if (!config.output) {
  config.output = path.resolve(process.cwd(), argv.output || './output/');
}
if (!config.theme) {
  console.log('The --theme command line argument is required.');
  return;
}

// process

var pi = require('pipe-iterators'),
    through = require('through2'),
    glob = require('wildglob'),
    mkdirp = require('mkdirp');

var stream = require('../index.js').stream,
    Theme = require('../index.js').Theme;
    md = require('../index.js').md;

var templatePath = config.theme,
    assetPath = config.theme + '/assets';

var meta = { blog: config.blog, authors: config.authors },
    theme = new Theme({
  templatePath: templatePath,
  meta: meta
});

var pipelines = require('../index.js').pipelines(theme, config.input, config.output);

glob.stream(config.input + '/**')
    .pipe(pi.pipeFirst([

  // fixme: duplicated in stream.read
  pi.filter(function(filename) {
    var stat = fs.statSync(filename);
    return stat.isFile();
  }),

  // for non-markdown files: copy the file.
  through.obj(function(filename, enc, onDone) {
    var ext = path.extname(filename);
    if (ext === '.md' || ext === '.markdown') {
      this.push(filename);
      return onDone();
    }
    var target = path.normalize(filename.replace(config.input, config.output));
    mkdirp(path.dirname(target), function(err) {
      if (err) {
        throw err;
      }
      console.log('Copy non-markdown file', filename, '=>', target);
      fs.createReadStream(filename).pipe(fs.createWriteStream(target));
      return onDone();
    });
  }),

  stream.read(),
  md.parseHeader(),
  md.parseMd(),
  md.annotateMdHeadings(),

  // add helper + template that uses the headings

  md.highlightJs(),
  md.convertMd(),

  // this would make a good example of why pipeFirst is not always what you want when you
  // are going from doing one operation to doing two operations, since it
  // would return the first item, which would leave a hanging pipe for the latter item
  // ... what you'd want is to pipe into the first item but pipe out of the last item.
  // Maybe pipe-iterators.pipe should do the right thing given
  // .pipe([ foo, [ first, ..., last], bar)

  // make sure that the path extension is adjusted to html before anything else happens

  // This creates '/foo.html' style links and files
  // pi.mapKey('path', function(p) { return path.dirname(p) + '/' + path.basename(p, path.extname(p)) + '.html'; }),
  //
  // TODO: document this and make it configurable.
  //
  // This leaves the '.html' part off from links. When the filename generation in the posts pipeline
  // detects no extname, it will append '/index.html', resulting in '/foo/index.html' style output
  // which will match the correct output on servers which support a index page.
  pi.mapKey('path', function(p) { return path.dirname(p) + '/' + path.basename(p, path.extname(p)); }),

  stream.fileToPost(meta, config.input),
  stream.parsePublishedAt(),
  stream.parseTags(),
  stream.sortByPublishedAt(),

  pi.fork(pipelines.page),

  // no drafts, no pages past this point
  pi.filter(function(post) { return !post.draft && !post.page; }),

  pi.fork(
    pipelines.post,
    pipelines.index,
    pipelines.postRSS,

    pi.pipeFirst([
      stream.groupByTag(),
      pi.fork(
        pipelines.tag,
        pipelines.tagRSS
      )
    ]),
    pi.pipeFirst([
      stream.groupByAuthor(),
      pi.fork(
        pipelines.author,
        pipelines.authorRSS
      )
    ])
  )
]));

// copy assets
glob.stream(assetPath + '/**' )
  .pipe(stream.read())
  .pipe(pi.mapKey('path', function(p) { return path.normalize(p.replace(assetPath, config.output + '/assets/')); }))
  .pipe(pi.forEach(function(obj) { console.log('write theme asset:', obj.path); }))
  .pipe(stream.dest());

var ghostAssetPath = path.normalize(__dirname + '/../public/assets');

glob.stream(ghostAssetPath + '/**' )
  .pipe(stream.read())
  .pipe(pi.mapKey('path', function(p) { return path.normalize(p.replace(ghostAssetPath + '/', config.output + '/assets/')); }))
  .pipe(pi.forEach(function(obj) { console.log('write base asset:', obj.path); }))
  .pipe(stream.dest());
